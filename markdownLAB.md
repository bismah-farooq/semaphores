# CECS 326 Lab 2: Concurrent Processing, Shared Memory, and Semaphores

<img width="1440" height="900" alt="326 - lab2 " src="https://github.com/user-attachments/assets/2a5511df-8e89-4d29-8e2b-32472d5e3844" />

### Q1. In what order should you perform the actions to create shared memory? (HINT: A minimum of three functions must be used the first time you create shared memory.)
To establish shared memory for the first time, a process must make three function calls in the following order. The shm_open() function creates or opens the shared memory object and returns a file descriptor that refers to it. Next, the process must call ftruncate() on that file descriptor to set the size of the shared memory region to be at least as large as the size of the data structure that will be shared. Finally, mmap() maps the shared memory object into the process's virtual address space and returns a pointer by which the memory can be accessed and modified. When shared memory is established for the first time, these three steps must occur in this order.

### Q2. What is the return type of mmap, and what can you do with it? (If you are unfamiliar with C/C++, you might need to do some personal research in order to understand this data type.)
The mmap() function returns a pointer of type void *. This generic pointer can be cast to any desired data type; for instance, a pointer to a struct stored in shared memory. Once the pointer has been cast-for instance, to struct Dungeon *, the process can directly access and modify the fields of the struct as if it were regular memory. In this way, multiple processes are able to read and write to the same shared data in a synchronized manner since the mapping reflects the contents of the shared memory.

### Q3. What does fork() return, and how can that information be used?
The return value from fork() has different meanings depending on whether the code is executed in the parent or in the child process. In the parent process, fork() returns the child's process ID, by which the parent can keep track of, send signals to, or otherwise manage the child. In the child process, fork() returns zero, enabling the program to execute a different block of code than the parent. If fork() returns a negative value, this indicates that the attempt at creating a new process has failed. These return values enable one program to split into two flows of execution.

### Q4. If exec works as intended, what happens to the process that calls it?
Whenever any of the exec family of functions succeeds, the calling process is completely replaced by a new program: its code, data, stack, and heap are overwritten, and execution starts at the entry point of the new program. An important point to note, however, is that the process ID does not change. Since the process image is replaced, exec does not return unless an error occurred. Consequently, any code placed after the exec call will not be executed if the call is successful.

### Q5. Do all three functions for shared memory need to be called in every single process after the first? If yes, why? If no, which ones are needed, and why would you not need to call all of them?
Not all processes need to call all shared memory management functions. Only the first process-usually the main game launcher-needs to use shm_open() with the O_CREAT flag, followed by ftruncate(), and then mmap(), because this is the process that needs to create and size the shared memory segment. The other processes will use only shm_open() without the O_CREAT flag-it will open an existing shared memory object-and mmap() to map it into their address space. They will not call ftruncate() because resizing shared memory after its creation would corrupt or erase the shared data. Therefore, only the creator calls all three functions, while other processes use only shm_open() and mmap(). 

### Q6. What does a struct look like in memory, and if I store a struct in shared memory, how do I access its various fields?
A struct in C is laid out in memory as a block of contiguous bytes, where each field is placed in order, possibly with padding inserted for alignment. When a struct is placed in shared memory, its layout remains the same as it would be in normal program memory. If a process gets a pointer to shared memory through mmap(), it can access the fields of a struct using the returned pointer directly. For instance, if struct Dungeon *d points to shared memory, then accessing d->enemy. health and modifying d->treasure[0] works the same as with any regular struct in memory. The only difference is that other processes also see the updates, as the memory is shared. 

### Q7. How do I determine the size of a struct in bytes?
The total size in bytes of a struct is determined via the sizeof operator. For example, given sizeof(struct Dungeon), the compiler computes the total number of bytes the struct will require to be stored, including all fields plus any padding for alignment. This is a key value when creating shared memory - it needs to be passed to both ftruncate() and mmap() to ensure the correct amount of shared space is allocated and mapped. Using sizeof ensures this size is accurate, even if the struct is changed at some point in the future.
